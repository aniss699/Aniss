Parfait â€” on concentre uniquement sur la section Profil. Voici un prompt prÃªt Ã  coller dans Replit qui cadre strictement le pÃ©rimÃ¨tre (profil clients + prestataires), ajoute lâ€™IA de complÃ©tude et les mots-clÃ©s/compÃ©tences pour le matching, sans toucher au reste de lâ€™app.

â¸»

PROMPT REPLIT â€” Refonte SECTION PROFIL uniquement

(Clients & Prestataires) avec IA de complÃ©tude + tags compÃ©tences

ğŸ¯ PÃ©rimÃ¨tre & contraintes (trÃ¨s important)
	â€¢	Ne modifier que la section Profil et les fichiers partagÃ©s strictement nÃ©cessaires (types/utilitaires).
	â€¢	Aucun changement sur les pages Missions/Marketplace/Accueil, aucune suppression dâ€™existants.
	â€¢	Pas de refonte globale du router : ajouter seulement les routes Profil si manquantes.
	â€¢	ZÃ©ro rÃ©gression : pas de rename de composants globaux, pas dâ€™upgrade de dÃ©pendances.
	â€¢	Fonctions IA encapsulÃ©es et optionnelles (fallback local). Ne pas rÃ©introduire dâ€™erreur analyzeWithAI non dÃ©finie.

â¸»

ğŸ—ƒï¸ Types & utilitaires (additifs, non-cassants)

CrÃ©er/mettre Ã  jour (additif uniquement) :
	â€¢	shared/types/profile.ts
	â€¢	shared/utils/profileScore.ts
	â€¢	shared/utils/keywords.ts

shared/types/profile.ts

export type UserRole = "client" | "provider";

export interface BaseProfile {
  userId: string;
  role: UserRole;
  displayName: string;
  avatarUrl?: string;
  headline?: string;
  bio?: string;
  location?: { city?: string; country?: string; lat?: number; lng?: number };
  languages?: string[];               // ex: ["fr","en"]
  keywords?: string[];                // mots-clÃ©s libres
  skills?: Array<{ name: string; level?: 1|2|3|4|5 }>;
  industries?: string[];
  portfolio?: Array<{ title: string; url?: string; image?: string; description?: string }>;
  certifications?: Array<{ name: string; issuer?: string; year?: number }>;
  availability?: { modes?: ("on-site"|"remote")[]; hoursPerWeek?: number; timezones?: string[]; earliestStartDate?: string };
  rates?: { currency: "EUR"; rateType?: "hourly"|"fixed"; min?: number; max?: number };
  preferences?: { visibility?: "public"|"private"|"anonymized"; gdprConsent?: boolean };
  completeness?: number;              // calculÃ©
  badges?: string[];
  createdAt: string; updatedAt: string;
}

export interface ClientProfile extends BaseProfile {
  company?: { name?: string; siret?: string; size?: "solo"|"TPE"|"PME"|"ETI"|"GE" };
  pastBudgets?: number[];
}

export interface ProviderProfile extends BaseProfile {
  yearsExperience?: number;
  serviceAreas?: string[];
  equipment?: string[];
}

export type AnyProfile = ClientProfile | ProviderProfile;

shared/utils/profileScore.ts
	â€¢	Exporter computeProfileCompleteness(p: Partial<AnyProfile>): number
RÃ¨gles simples (pondÃ©rations) : avatar (5), displayName (5), headline (10), bio (15), location (5), languages (5), keywords (10), skills (20), portfolio/certifs (10), availability/rates (10), preferences.gdprConsent (5). Clamp 0â€“100.

shared/utils/keywords.ts
	â€¢	normalizeTags(input: string[]): string[] â†’ trim, lower, dÃ©doublonne.
	â€¢	expandSynonyms(tags: string[]): string[] â†’ petit dictionnaire interne (FR) pour rapprocher les variantes (â€œdev webâ€â†’â€œdÃ©veloppement webâ€, â€œseoâ€â†’â€œrÃ©fÃ©rencement naturelâ€, etc.).
	â€¢	Ne pas appeler dâ€™API externe.

â¸»

ğŸ§­ UI Profil (nouveaux Ã©crans, dans un dossier dÃ©diÃ©)

CrÃ©er uniquement sous client/src/profile/ :
	â€¢	ProfileDashboard.tsx
	â€¢	Affiche rÃ©sumÃ© profil + ProgressBar de complÃ©tude (utilise computeProfileCompleteness).
	â€¢	Cartes â€œsection incomplÃ¨teâ€ avec CTA â€œComplÃ©terâ€ (mÃ¨ne vers lâ€™Ã©tape du wizard).
	â€¢	ProfileWizard.tsx (assistant multi-Ã©tapes, sauvegarde par Ã©tape)
Ã‰tapes :
	1.	Infos gÃ©nÃ©rales (photo, nom affichÃ©, rÃ´le, headline, bio)
	2.	Localisation & Langues
	3.	CompÃ©tences & Mots-clÃ©s (Ã©diteur de tags, auto-complÃ©tion locale, normalisation)
	4.	Portfolio & Certifications
	5.	DisponibilitÃ© & Tarifs (prestataire) / SociÃ©tÃ© & Historique budgets (client)
	6.	PrÃ©fÃ©rences & ConfidentialitÃ© (visibilitÃ©, consentement)
	â€¢	KeywordsSkillsEditor.tsx
	â€¢	Input tags (ajout/suppression), suggestions locales (listes statiques FR), appelle normalizeTags + expandSynonyms.
	â€¢	AIAssistButtons.tsx
	â€¢	Boutons : â€œProposer avec lâ€™IAâ€, â€œComplÃ©ter avec lâ€™IAâ€, â€œAmÃ©liorer mon texteâ€.
	â€¢	Appelle des helpers safe (voir section IA). Afficher skeleton/loading + rÃ©sultat diffable avant dâ€™appliquer.
	â€¢	ProfilePublicView.tsx
	â€¢	Vue publique (respecte preferences.visibility).

Styles & accessibilitÃ©
	â€¢	Mobile-first, FR, ARIA labels, navigation clavier.
	â€¢	Ne pas modifier le design global hors profil.

â¸»

ğŸ”— Routes (profil uniquement)

Ajouter uniquement si absentes, puis enregistrer dans le router sans toucher aux autres routes :
	â€¢	/profil â†’ ProfileDashboard
	â€¢	/profil/editer â†’ ProfileWizard
	â€¢	/profil/:userId â†’ ProfilePublicView

Si le projet utilise Wouter/React Router, ajouter les <Route> correspondantes dans le fichier router existant, sans retirer/modifier les routes actuelles.

â¸»

ğŸ¤– IntÃ©gration IA (encapsulÃ©e, sans dÃ©pendance externe obligatoire)

CrÃ©er client/src/ai/profileAssist.ts :

import { AnyProfile } from "../../shared/types/profile";
import { normalizeTags, expandSynonyms } from "../../shared/utils/keywords";

type AIResult<T> = { ok: true; data: T } | { ok: false; error: string };

async function callExistingAICore<T>(fn: string, payload: unknown): Promise<AIResult<T>> {
  // 1) Si une fonction globale/SDK existe dÃ©jÃ , lâ€™utiliser prudemment (try/catch)
  // 2) Sinon, fallback local dÃ©terministe
  try {
    // @ts-ignore
    if (typeof window !== "undefined" && typeof window.aiCore?.[fn] === "function") {
      // @ts-ignore
      const data = await window.aiCore[fn](payload);
      return { ok: true, data };
    }
  } catch (e: any) {
    return { ok: false, error: e?.message || "AI core error" };
  }
  return { ok: false, error: "AI core unavailable" };
}

export async function aiEnhanceText(input: string): Promise<string> {
  const res = await callExistingAICore<string>("enhanceText", { input });
  if (res.ok) return res.data;
  // Fallback simple : capitalisation + suppression doublons espaces
  return input.replace(/\s+/g, " ").replace(/(^\w|\.\s+\w)/g, s => s.toUpperCase());
}

export async function aiSuggestProfileImprovements(p: Partial<AnyProfile>): Promise<Partial<AnyProfile>> {
  const res = await callExistingAICore<Partial<AnyProfile>>("suggestProfile", p);
  if (res.ok) return res.data;
  // Fallback heuristique local : ajoute headline si vide, propose tags depuis bio
  const out: Partial<AnyProfile> = { ...p };
  if (!out.headline && p.role === "provider") {
    out.headline = "Prestataire expÃ©rimentÃ© â€” rÃ©actif et orientÃ© rÃ©sultats";
  }
  if (!out.keywords?.length && p.bio) {
    const seed = (p.bio.match(/\b(seo|wordpress|peinture|mÃ©nage|dÃ©pannage|plomberie|Ã©lectricitÃ©|data|flutter|react)\b/gi) || []);
    out.keywords = expandSynonyms(normalizeTags(seed));
  }
  return out;
}

export async function aiGenerateKeywordsSkills(texts: { bio?: string; headline?: string }): Promise<{keywords: string[]; skills: string[]}> {
  const res = await callExistingAICore<{keywords: string[]; skills: string[]}>("extractTags", texts);
  if (res.ok) return res.data;
  const base = (texts.bio || "" + " " + (texts.headline || "")).toLowerCase();
  const dict = ["seo","rÃ©fÃ©rencement naturel","wordpress","react","flutter","plomberie","Ã©lectricitÃ©","peinture","nettoyage","data","excel","audit"];
  const found = dict.filter(d => base.includes(d));
  return { keywords: expandSynonyms(normalizeTags(found)), skills: expandSynonyms(normalizeTags(found)) };
}

Objectif : aucune erreur Can't find variable: analyzeWithAI. Tout est encapsulÃ©, avec fallback local.

â¸»

ğŸ’¾ Persistance (non-intrusive)
	â€¢	CrÃ©er des hooks dans client/src/profile/useProfile.ts qui utilisent le store/fetch existant (TanStack Query si prÃ©sent).
	â€¢	Si lâ€™API nâ€™existe pas encore, mock local (localStorage) uniquement pour le profil, sans impacter le reste.

â¸»

ğŸ§ª Tests & vÃ©rifs ciblÃ©s
	â€¢	Unit : computeProfileCompleteness, normalizeTags, expandSynonyms.
	â€¢	Smoke UI : montage ProfileDashboard & ProfileWizard sans erreurs.
	â€¢	Non-rÃ©gression : build Vite OK, aucune 404 nouvelle hors /profil*.

â¸»

âœ… CritÃ¨res dâ€™acceptation (doit Ãªtre vÃ©rifiable Ã  la main)
	1.	Naviguer vers /profil affiche le dashboard avec une barre de complÃ©tude (0â€“100).
	2.	Bouton â€œComplÃ©terâ€ ouvre /profil/editer (wizard) avec 6 Ã©tapes dÃ©crites plus haut.
	3.	Dans lâ€™Ã©tape CompÃ©tences & Mots-clÃ©s, je peux ajouter/supprimer des tags, voir des suggestions, et ils sont normalisÃ©s.
	4.	Les boutons IA proposent :
	â€¢	une amÃ©lioration de texte (headline/bio) sans casser lâ€™UI,
	â€¢	des mots-clÃ©s/compÃ©tences suggÃ©rÃ©s,
	â€¢	une complÃ©tion automatique de certains champs vides.
En cas dâ€™indisponibilitÃ© de lâ€™IA, un fallback local fournit une proposition basique (pas dâ€™erreur).
	5.	La vue publique /profil/:userId respecte la visibilitÃ© (public/private/anonymized).
	6.	Aucune rÃ©gression sur les autres pages (missions, accueil, marketplace). Build OK.

â¸»

ğŸ“ Notes dâ€™implÃ©mentation rapides
	â€¢	Utiliser un ProgressBar simple (calcul Ã  chaque sauvegarde dâ€™Ã©tape).
	â€¢	Enregistrer la progression par Ã©tape (prÃ©venir la perte de saisie).
	â€¢	Mettre des labels FR + aria-* pour lâ€™accessibilitÃ©.
	â€¢	Ne pas modifier les composants ou styles non liÃ©s au profil.

â¸»

Livrables attendus dans ce MR interne :
	â€¢	Dossier client/src/profile/ complet + hooks.
	â€¢	Fichiers shared/types/profile.ts, shared/utils/profileScore.ts, shared/utils/keywords.ts.
	â€¢	Tests unitaires sur les utilitaires.
	â€¢	Ajout minimal des routes /profil, /profil/editer, /profil/:userId.
	â€¢	README court client/src/profile/README.md (comment lancer, oÃ¹ brancher lâ€™API si disponible).

â¸»

Merci dâ€™appliquer ces changements exclusivement Ã  la section Profil, avec le strict minimum de couplage vers le reste de lâ€™app.